# -*- coding: utf-8 -*-
"""Untitled44.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1uua0MjXuiiLK2pF9uA0GWfLz6Bhvea4G
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt

# Define the K-means clustering algorithm
class MyKMeans:
    def __init__(self, num_clusters):
        # Initialize clusters
        self.num_clusters = num_clusters
        self.centroids = None

    def fit(self, input_data):
        # Initialize centroids randomly
        self.centroids = input_data[np.random.choice(input_data.shape[0], self.num_clusters, replace=False)]

        while True:
            # Assign each data point to the nearest centroid
            labels = self.assign_labels(input_data)

            # Update centroids based on the mean of assigned data points
            new_centroids = np.array([input_data[labels == i].mean(axis=0) for i in range(self.num_clusters)])

            # Check for convergence
            if np.all(new_centroids == self.centroids):
                break

            self.centroids = new_centroids

        return labels

    def assign_labels(self, input_data):
        # Calculation of distances between data points and centroids
        distances = np.array([[np.linalg.norm(point - centroid) for centroid in self.centroids] for point in input_data])
        # Assign labels by selecting the centroid index with the minimum distance for each data point
        labels = np.argmin(distances, axis=1)
        return labels

# Define the K-medoids clustering algorithm
class MyKMedoids:
    def __init__(self, num_clusters):
        # Initialize clusters
        self.num_clusters = num_clusters
        self.medoids = None

    def fit(self, input_data, max_iter=100):
        num_samples, num_features = input_data.shape

        # Initialize medoids randomly
        self.medoids = input_data[np.random.choice(num_samples, self.num_clusters, replace=False)]

        for _ in range(max_iter):
            # Assign each data point to the nearest medoid
            labels, distances = self.calculate_pairwise_distances(input_data)

            # Update medoids based on the total distance to other data points
            new_medoids = np.array([input_data[labels == i][np.argmin(distances[labels == i])] for i in range(self.num_clusters)])

            # Check for convergence
            if np.all(new_medoids == self.medoids):
                break

            self.medoids = new_medoids

        return labels

    def calculate_pairwise_distances(self, input_data):
        # Calculation of pairwise distances between data points and medoids
        distances = np.array([[np.linalg.norm(point - medoid) for medoid in self.medoids] for point in input_data])
        # Find the index of the medoid with the minimum distance for each data point
        labels = np.argmin(distances, axis=1)
        # Find the minimum distances from each data point to its nearest medoid
        min_distances = np.min(distances, axis=1)
        return labels, min_distances

# Load the dataset
dataset = pd.read_excel("dataset.xlsx").values

# Get user-defined value for K
num_clusters_value = int(input("Enter the number of clusters (K): "))

# Apply K-means clustering
kmeans = MyKMeans(num_clusters=num_clusters_value)
kmeans_labels = kmeans.fit(dataset)

# Apply K-medoids clustering
kmedoids = MyKMedoids(num_clusters=num_clusters_value)
kmedoids_labels = kmedoids.fit(dataset)

# Visualize the clusters with different colors
plt.scatter(dataset[:, 0], dataset[:, 1], c=kmeans_labels, cmap='Set1', label='K-means')
plt.scatter(kmeans.centroids[:, 0], kmeans.centroids[:, 1], c='red', marker='X', label='K-means centroids')

plt.scatter(dataset[:, 0], dataset[:, 1], c=kmedoids_labels, cmap='Set2', label='K-medoids')
plt.scatter(kmedoids.medoids[:, 0], kmedoids.medoids[:, 1], c='green', marker='X', label='K-medoids medoids')

plt.title(f'K-means and K-medoids Clustering (K={num_clusters_value})')
plt.xlabel('Feature A1')
plt.ylabel('Feature A2')
plt.legend()
plt.show()